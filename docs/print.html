<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>LSTS Documentation</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Large Scale Type Systems Tutorial: A Categorical View of Typed Lambda Calculus">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <link rel="sitemap" type="application/xml" title="Sitemap" href="/lsts-tutorial/sitemap.xml">

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-0FD3R3RGQD"></script>
        <script>
           window.dataLayer = window.dataLayer || [];
           function gtag(){dataLayer.push(arguments);}
           gtag('js', new Date());

           gtag('config', 'G-0FD3R3RGQD');
        </script>

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">User Guide</li><li class="chapter-item expanded "><a href="guide/installation.html"><strong aria-hidden="true">1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="guide/syntax.html"><strong aria-hidden="true">2.</strong> Syntax Overview</a></li><li class="chapter-item expanded affix "><li class="part-title">Tutorial</li><li class="chapter-item expanded "><a href="tutorial/terms.html"><strong aria-hidden="true">3.</strong> Terms</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/values.html"><strong aria-hidden="true">3.1.</strong> Value Expressions</a></li><li class="chapter-item expanded "><a href="tutorial/blocks.html"><strong aria-hidden="true">3.2.</strong> Block Expressions</a></li><li class="chapter-item expanded "><a href="tutorial/compounds.html"><strong aria-hidden="true">3.3.</strong> Compound Values</a></li><li class="chapter-item expanded "><a href="tutorial/quantifiers.html"><strong aria-hidden="true">3.4.</strong> Quantified Values</a></li></ol></li><li class="chapter-item expanded "><a href="tutorial/types.html"><strong aria-hidden="true">4.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/value_types.html"><strong aria-hidden="true">4.1.</strong> Value Types</a></li><li class="chapter-item expanded "><a href="tutorial/struct_types.html"><strong aria-hidden="true">4.2.</strong> Structured Types</a></li><li class="chapter-item expanded "><a href="tutorial/union_types.html"><strong aria-hidden="true">4.3.</strong> Union Types</a></li><li class="chapter-item expanded "><a href="tutorial/parameterized_types.html"><strong aria-hidden="true">4.4.</strong> Parameterized Types</a></li><li class="chapter-item expanded "><a href="tutorial/type_invariants.html"><strong aria-hidden="true">4.5.</strong> Type Invariants</a></li><li class="chapter-item expanded "><a href="tutorial/constant_types.html"><strong aria-hidden="true">4.6.</strong> Constant Types</a></li><li class="chapter-item expanded "><a href="tutorial/unification.html"><strong aria-hidden="true">4.7.</strong> Type Unification</a></li></ol></li><li class="chapter-item expanded "><a href="tutorial/kinds.html"><strong aria-hidden="true">5.</strong> Kinds</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/normal_kinds.html"><strong aria-hidden="true">5.1.</strong> Normal Kinds</a></li><li class="chapter-item expanded "><a href="tutorial/operations_on_kinds.html"><strong aria-hidden="true">5.2.</strong> Operations on Kinds</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Examples</li><li class="chapter-item expanded "><a href="examples/examples.html"><strong aria-hidden="true">6.</strong> Programs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="examples/right_triangles.html"><strong aria-hidden="true">6.1.</strong> Right Triangles</a></li><li class="chapter-item expanded "><a href="examples/goto_statement_considered_harmful.html"><strong aria-hidden="true">6.2.</strong> Jump Control Flow</a></li><li class="chapter-item expanded "><a href="examples/batteries_not_included.html"><strong aria-hidden="true">6.3.</strong> Batteries Not Included</a></li></ol></li><li class="chapter-item expanded "><a href="proof/proofs.html"><strong aria-hidden="true">7.</strong> Proofs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="proof/trivial.html"><strong aria-hidden="true">7.1.</strong> Trivial Proofs</a></li><li class="chapter-item expanded "><a href="proof/sqrt2.html"><strong aria-hidden="true">7.2.</strong> Irrationality of the Square Root of Two</a></li><li class="chapter-item expanded "><a href="proof/primes.html"><strong aria-hidden="true">7.3.</strong> Infinitude of Primes</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Reference Guide</li><li class="chapter-item expanded "><a href="cli/index.html"><strong aria-hidden="true">8.</strong> Command Line Tool</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cli/lsts_parse.html"><strong aria-hidden="true">8.1.</strong> lsts parse</a></li><li class="chapter-item expanded "><a href="cli/lsts_check.html"><strong aria-hidden="true">8.2.</strong> lsts check</a></li><li class="chapter-item expanded "><a href="cli/lsts_build.html"><strong aria-hidden="true">8.3.</strong> lsts build</a></li><li class="chapter-item expanded "><a href="cli/lsts_run.html"><strong aria-hidden="true">8.4.</strong> lsts run</a></li></ol></li><li class="chapter-item expanded "><a href="validity/soundness.html"><strong aria-hidden="true">9.</strong> Soundness</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="validity/kinds.html"><strong aria-hidden="true">9.1.</strong> Kinded Proofs</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Quantitative Information</li><li class="chapter-item expanded "><a href="perf/statistics.html"><strong aria-hidden="true">10.</strong> Performance</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="misc/contributors.html">Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">LSTS Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/andrew-johnson-4/lsts-tutorial" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><strong>lsts</strong> is a proof assistant and sometimes a programming language.
LSTS is designed for assisted reasoning in mathematical proofs.
For those feeling particularly adventurous, it may even be possible to use as a programming language.</p>
<ul>
<li>Lightweight. <a href="https://github.com/andrew-johnson-4/LSTS">LSTS</a> is only 3K sloc of Rust code with no dependencies.</li>
<li>Fast. <a href="perf/statistics.html">Benchmarks</a> compare to Rust itself for compilation speed and efficiency.</li>
<li>Familiar. The <a href="guide/syntax.html">Syntax</a> is usually similar to Coq, ML, or Haskell.</li>
</ul>
<h2 id="intended-audience"><a class="header" href="#intended-audience">Intended Audience</a></h2>
<p>This tutorial and reference has been compiled for people who have significant mathematical or programming experience and are looking to try something new.
LSTS is anything but average.
There are still huge pieces of functionality missing from LSTS.
There are also huge pieces of functionality that are already outperforming comparable software products.
Hopefully this guide will help you find something inspiring.
Soon this guide will help you also find something useful.
You can help us improve more quickly by <a href="https://github.com/andrew-johnson-4/LSTS/issues">suggesting improvements or asking questions</a>.</p>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>LSTS is free and open source. You can find the source code on
<a href="https://github.com/andrew-johnson-4/LSTS">GitHub</a> and issues and feature requests can be posted on
the <a href="https://github.com/andrew-johnson-4/LSTS/issues">GitHub issue tracker</a>. LSTS relies on the community to fix bugs and
add features: if you would like to contribute, please read
the <a href="https://github.com/andrew-johnson-4/LSTS/blob/main/CODE_OF_CONDUCT.md">Code of Conduct</a> guide and consider opening
a <a href="https://github.com/andrew-johnson-4/LSTS/pulls">pull request</a>.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>The LSTS source and documentation are released under
the <a href="https://github.com/andrew-johnson-4/LSTS/blob/main/LICENSE">MIT License</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>There are multiple ways to install the lsts CLI tool.
Choose any one of the methods below that best suit your needs.</p>
<h2 id="build-from-source-using-rust"><a class="header" href="#build-from-source-using-rust">Build from source using Rust</a></h2>
<p>To build the <code>lsts</code> executable from source, you will first need to install Rust and Cargo.
Follow the instructions on the <a href="https://www.rust-lang.org/tools/install">Rust installation page</a>.</p>
<p>Once you have installed Rust, the following command can be used to build and install lsts:</p>
<pre><code class="language-sh">cargo install lsts
</code></pre>
<p>This will automatically download lsts from <a href="https://crates.io/">crates.io</a>, build it, and install it in Cargo's global binary directory (<code>~/.cargo/bin/</code> by default).</p>
<p>To uninstall, run the command <code>cargo uninstall lsts</code>.</p>
<h3 id="installing-the-latest-master-version"><a class="header" href="#installing-the-latest-master-version">Installing the latest master version</a></h3>
<p>The version published to crates.io will ever so slightly be behind the version hosted on GitHub.
If you need the latest version you can build the git version of lsts yourself.</p>
<pre><code class="language-sh">cargo install --git https://github.com/rust-lang/LSTS.git lsts
</code></pre>
<p>Again, make sure to add the Cargo bin directory to your <code>PATH</code>.</p>
<p>If you are interested in making modifications to lsts itself, check out the <a href="https://github.com/andrew-johnson-4/LSTS/blob/master/CONTRIBUTING.md">Contributing Guide</a> for more information.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lsts-syntax"><a class="header" href="#lsts-syntax">LSTS Syntax</a></h1>
<p>LSTS syntax is derived from Lambda Calculus.
Extensions to the Lambda Calculus syntax are modelled after those from previous languages also derived from Lambda Calculus.
Some of these languages include Coq, ML, and Haskell.</p>
<h1 id="define-a-type"><a class="header" href="#define-a-type">Define a type</a></h1>
<p>Types describe the properties of a Term.</p>
<pre><code class="language-lsts">type Prime: Integer
   where self &gt; 1
   and   a:Integer. 2&gt;a || a&gt;self-1 || self%a != 0
</code></pre>
<p>Here we define a Prime number.
Firstly, a Prime number is an Integer.
Secondly, a Prime number is greater than 1.
Thirdly, a Prime number is not evenly divisible by any other number greater than 1.</p>
<h1 id="bind-a-value"><a class="header" href="#bind-a-value">Bind a value</a></h1>
<p>Let bindings attach properties to Terms.</p>
<pre><code class="language-lsts">let x:Prime = 3;
let y:Prime = 4;
</code></pre>
<p>In the first binding of <em>x</em>, the number 3 satisfies the bounds and is accepted as an inhabitant of its Type.
In the second binding of <em>y</em>, the number 4 does not satisfy the primality test defined by Prime and will be rejected.
A rejected program will typically result in an error and message if lsts is invoked from the command line.</p>
<p>Let bindings do not need to be inhabited.
The value can be omitted, at which point the binding becomes a supposition.
This format is very useful for constructing quantified proofs or proofs by contradiction.</p>
<pre><code class="language-lsts">forall x:Odd. x%2 == 1
</code></pre>
<h1 id="kind-a-type"><a class="header" href="#kind-a-type">Kind a type</a></h1>
<p>Kinds are <em>types for types</em>.
Kinds are simple, only allowing Named kinds and possibly parameters.
The three built-in kinds are Term, Constant, and Nil.
New kinds do not need to be defined before they are used.
Kinds are introduced with double-colon syntax, similar to the single-colon syntax used for types.</p>
<pre><code class="language-lsts">1 : Second :: Unit
</code></pre>
<p>Here we say that Second is a Unit type rather than a Term type.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="terms"><a class="header" href="#terms">Terms</a></h1>
<p>Terms inhabit Types.
Terms are also called Values.
A Value has a finite representation.
When run as a program, these values will be represented as 1s and 0s.</p>
<pre><code class="language-lsts">True: Boolean;

1: Integer;

1.2: Real;

1.2+3i: Complex;

'a': Character;

&quot;bc&quot;: String;

(1,True): (Odd, Boolean);

[7, 11]: Prime[];

{2, 6, 10}: Set&lt;Even&gt;;

{1=2, 3=4, 5=6, 7=8}: Map&lt;Integer,Integer&gt;;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="value-expressions"><a class="header" href="#value-expressions">Value Expressions</a></h1>
<p>Values are existential proofs that a type bound can be satisfied.
The expression &quot;1 is an Integer&quot; proves that integers exist.
We refer to this important relationship as <em>inhabitance</em>.
Values inhabit Types. Types inhabit Kinds.
A type with no values is said to be <em>vacuous</em>.</p>
<h3 id="constant-values"><a class="header" href="#constant-values">Constant Values</a></h3>
<p>Constant values are assigned to a Type through a combination of inference and regex pattern matching.
A Constant Type will define a regex that matches some value string.
An example of a constant type is the traditional concept of an Integer.
An Integer is denoted as a string of digits: [0-9]+.</p>
<p>After creating a value, it can be passed around</p>
<pre><code class="language-lsts">1 + 2
</code></pre>
<p>or assigned to a binding</p>
<pre><code class="language-lsts">let x:Integer = 5
</code></pre>
<h3 id="infix-operators"><a class="header" href="#infix-operators">Infix Operators</a></h3>
<p>LSTS recognizes the special syntax of some common infix operators.
The definition of what these operators do is left to the programmer or maybe a prelude.</p>
<p>There are boolean operators</p>
<pre><code class="language-lsts">a &amp;&amp; b || not(c)
</code></pre>
<p>There are arithmetic operators</p>
<pre><code class="language-lsts">1^2 + 3 * 4 / 5 - 6 % 7
</code></pre>
<p>There are even comparison operators</p>
<pre><code class="language-lsts">1 &lt; 2 &lt;= 3 == 4 != 5 &gt; 6 &gt;= 7
</code></pre>
<p>These operations form the basis of logical calculation in LSTS.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="block-expressions"><a class="header" href="#block-expressions">Block Expressions</a></h1>
<p>Blocks group one or more statements together into a logical unit.
The existence of block statements is to some extent an artifact
of the development team's familiarity to programming languages
and unfamiliarity with traditional proof assistants. All
block statements exist to create quantified proofs of properties
in a style familiar to programmers.</p>
<h3 id="loops"><a class="header" href="#loops">Loops</a></h3>
<p>Loops can prove very interesting properties of language.</p>
<p>A while loop can prove that a condition is terminal, subject to some computation.</p>
<pre><code class="language-lsts">let more(): Boolean;
while more() {
   //does this ever end?
}
</code></pre>
<p>For completeness' sake we have also built most traditional control-flow blocks.</p>
<pre><code class="language-lsts">for x:Prime in primes {
   //this is not unlike a forall statement
}
</code></pre>
<pre><code class="language-lsts">loop {
   //this is called a 1+ loop
} while( do_continue() )
</code></pre>
<h3 id="if-conditionals"><a class="header" href="#if-conditionals">If Conditionals</a></h3>
<p>Where would we be without branching conditionals?</p>
<pre><code class="language-lsts">if a then b
else if c then d
else e
</code></pre>
<p>We also define pattern matching conditionals which unpack structured data.</p>
<pre><code class="language-lsts">if let Some(a) = b {
   a: Odd
}
</code></pre>
<h3 id="exhaustive-pattern-matching"><a class="header" href="#exhaustive-pattern-matching">Exhaustive Pattern Matching</a></h3>
<p>For complex value unpacking we have match blocks.</p>
<pre><code class="language-lsts">match x {
   EnumBranch1(y) =&gt; { y: Prime; },
   EnumBranch2(z,w) =&gt; { z: Odd; w: Even; },
}
</code></pre>
<h3 id="grouping-blocks"><a class="header" href="#grouping-blocks">Grouping Blocks</a></h3>
<p>If you just want to group some statements together, for this we have simple brace blocks.</p>
<pre><code class="language-lsts">{
   let x: Odd;
   a: Integer;
   b: Prime;
   x + a + b: Integer;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compound-values"><a class="header" href="#compound-values">Compound Values</a></h1>
<p>A compound value is made up of smaller parts.
Some compounds contain heterogenous components.
Some compounds contain homogenous components.
The user can define custom compound values as new types.
Other compound values are implicitly introduced.</p>
<h3 id="tuples"><a class="header" href="#tuples">Tuples</a></h3>
<p>A Tuple is an extension of the English concept of &quot;double&quot;, &quot;triple&quot;, &quot;quadruple&quot;, &quot;n-tuple&quot;.
Tuples contain a number of heterogenous values.
A Tuple value is introduced using parentheses and comma syntax.
Tuple types are also introduced using parentheses and comma syntax.</p>
<pre><code class="language-lsts">(1,'a',&quot;bc&quot;,True) : (Number, Character, String, Boolean)
</code></pre>
<h3 id="named-tuples"><a class="header" href="#named-tuples">Named Tuples</a></h3>
<p>Tuples can be given names and type signatures in a type definition.
Named tuples must declare the type of all of their contained values.</p>
<pre><code class="language-lsts">type MyStruct = {
   x: Number,
   c: Character,
   s: String,
   b: Boolean
}
</code></pre>
<p>After a named tuple has been defined, it can be instantiated with similar syntax.</p>
<pre><code>MyStruct { x=1, c='a', s=&quot;bc&quot;, b=True }
</code></pre>
<h3 id="union-types"><a class="header" href="#union-types">Union Types</a></h3>
<p>Union Types define branched types.
A Union value may match with one of, but not multiple of, the Union's branches.
Each branch in a Union is given a tag.
This kind of Union is sometimes called a Tagged Union for that reason.</p>
<pre><code class="language-lsts">type MyUnion = FirstTag { x:Integer }
             | SecondTag { y:Even }
             | ThirdTag { z:Odd }
             | FourthTag { x:Prime, y:Prime, z:Prime }
</code></pre>
<p>Union Types are instantiated with the same syntax as for named tuples.</p>
<pre><code class="language-lsts">SecondTag { y:8 }
</code></pre>
<h3 id="lists"><a class="header" href="#lists">Lists</a></h3>
<p>Lists have builtin syntax for their types and for their values.</p>
<pre><code class="language-lsts">let xs:Integer[3] = [1,2,3];
let vs:Odd[] = [3,5,11,15,17]
</code></pre>
<h3 id="sets"><a class="header" href="#sets">Sets</a></h3>
<p>Sets have builtin syntax for their types and for their values.</p>
<pre><code class="language-lsts">let ss:Set&lt;Integer&gt; = {1, 2, 2, 3}
</code></pre>
<h3 id="maps"><a class="header" href="#maps">Maps</a></h3>
<p>Maps have builtin syntax for their types and for their values.</p>
<pre><code class="language-lsts">let ms:Map&lt;Integer,Prime&gt; = { 1=2, 2=3, 3=5, 4=7 }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quantified-values"><a class="header" href="#quantified-values">Quantified Values</a></h1>
<p>Quantified Values inhabit Quantified Types.
This concept maps exactly to the programming concept of iterators,
so we will just steal that syntax and use it here.</p>
<h3 id="iterators"><a class="header" href="#iterators">Iterators</a></h3>
<p>A naked iterator looks much like a for loop.</p>
<pre><code class="language-lsts">for i:Integer in ls yield i+1
</code></pre>
<h3 id="containers"><a class="header" href="#containers">Containers</a></h3>
<p>Iterators can fill containers,</p>
<p>like sets</p>
<pre><code class="language-lsts">{for a:Integer in s yield a*a}
</code></pre>
<p>or lists</p>
<pre><code class="language-lsts">[for a:Integer in s yield a*a]
</code></pre>
<p>or maps.</p>
<pre><code class="language-lsts">{for a:Integer in s yield a=a*a}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types"><a class="header" href="#types">Types</a></h1>
<p>A Type describes a property of a Term.
Terms are multifaceted and can be described from a variety of perspectives.
A Term can have multiple properties, so Terms can also have multiple Types.</p>
<p>Each Term is associated with a singular Type Expression.
A Type Expression represents all properties of that term, structured in Conjunctive Normal Form (CNF).
Conjunctive Normal Form is just a way of saying that all the Ands are at the top level,
above the Ors.</p>
<p>Two Types can be attached to one Term.</p>
<pre><code class="language-lsts">a: Integer + Prime
</code></pre>
<p>One Type can imply another Type. When this happens there is an implicit expansion of the implication to enforce CNF.</p>
<pre><code class="language-lsts">type Aa: Bb;
a : Aa      //                Aa + Aa =&gt; Bb
            //rewrite as just Aa + Bb
a : Aa + Bb
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="value-types"><a class="header" href="#value-types">Value Types</a></h1>
<p>Value types are defined by a regular expression that matches a subset of <em>value characters</em>.
Value characters are defined in the LSTS lexer as character ranges associated with values.
In this fashion LSTS does not really define any builtin value types.
All value types are defined by the user or by a prelude that is loaded by the user.</p>
<pre><code class="language-lsts">type Number;
type Integer   : Number = /^[0-9][_0-9]*([eE][_0-9]+)?$/;
type Real      : Number = /^[0-9][_.0-9]*([eE][-]?[_0-9]+)?$/;
type Complex   : Number = /^[0-9][_.0-9]*([eE][-]?[_0-9]+)?([+][0-9][_.0-9]*([eE][-]?[_0-9]+)?[i])?$/;
</code></pre>
<p>As you can see in the above code section, numerical types can be associated with a definitive regular expression.
If that regular expression matches with a value, then the type will be associated.
One caveat is that only the first match will associate its type.
Here the number 34 will be assigned only the type Integer because that is the first match.
If you want for 34 to be a Real number then you should write it as 34.0 so that the Integer regular expression fails to match.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structured-types"><a class="header" href="#structured-types">Structured Types</a></h1>
<p>Structured types are also referred to as Named Tuples.
A structured type is a named type with optional parameters.
An example of a structured type would be the concept of a Point in N-dimensional space.</p>
<pre><code class="language-lsts">struct Point2D&lt;N:Number&gt; = { x:N, y:N };
struct Point3D&lt;N:Number&gt; = { x:N, y:N, z:N };
struct Point4D&lt;N:Number&gt; = { x:N, y:N, z:N, w:N };
</code></pre>
<p>Type parameters can be inferred when the struct is instantiated.</p>
<pre><code class="language-lsts">Point3D { x:1, y:2, z:3 }
</code></pre>
<p>If you want to provide a more explicit parameter bound, then you can annotate the parameters on the constructor.</p>
<pre><code class="language-lsts">Point2D&lt;Prime&gt; { x:7, y:17 }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="union-types-1"><a class="header" href="#union-types-1">Union Types</a></h1>
<p>Union Types define multiple branches of possible structured data.
Each branch must also be annotated with a tag.
For this reason Union Types are also called Tagged Unions.
Each branch of a Union Type is declared with a tag and its structured data.
Multiple branches are separated with a vertical bar.</p>
<pre><code class="language-lsts">type Boolean = True | False;
type Option&lt;A&gt; = None | Some { value:A };
</code></pre>
<p>Union types are instantiated in identical fashion to structured data.
The only difference is that instead of the type name, the tag name is used to prefix the data.</p>
<pre><code class="language-lsts">Some { value:5 }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parameterized-types"><a class="header" href="#parameterized-types">Parameterized Types</a></h1>
<p>Type parameters create generic types.
A Generic Type is a single type definition that can have multiple type signatures.
Each type signature will have a similar, but not quite exactly the same, structure.
Parameters can be added to any type definition to create a generic type.</p>
<pre><code class="language-lsts">type Point2D&lt;N:Integer&gt; = { x:N, y:N };

type Result&lt;OK,ERR&gt; = Ok { ok: OK }
                    | Err { err: ERR };
</code></pre>
<p>Type parameters can also be added to any parameterized type in its constructor.
This creates a very strict enforcement of the type's parameter bounds.</p>
<pre><code class="language-lsts">Ok&lt;Odd,String&gt; { ok: 1 }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-invariants"><a class="header" href="#type-invariants">Type Invariants</a></h1>
<p>Type invariants carry a lot of the weight of proofs in practice.
Type invariants are inherently dependently typed.
A Dependent Type describes a subset of the values of a Total Type.</p>
<p>A Total Type describes <em>all values that can be represented</em>.
UnsignedInteger32 would a Total Type.
UnsignedInteger32 can represent all 32-bit unsigned integers.</p>
<p>By comparison, a dependent type, or implicitly any type with invariants, would not be Total.
Odd numbers are a subset of all Integers.
Odd numbers might be represented as Integers, but not all Integers are Odd.</p>
<pre><code class="language-lsts">987654321 : Odd + Integer
</code></pre>
<p>Type Invariants are dependent properties that are attached to a type definition.
The definition of Odd is as follows:</p>
<pre><code class="language-lsts">type Odd: Integer
   where self%2 | 1
</code></pre>
<p>Multiple properties can be attached to the same type definition.</p>
<pre><code class="language-lsts">type Factor23: Integer
   where self%2 | 0
   and   self%3 | 0;
</code></pre>
<p>The <em>self</em> keyword represents some value of the declared type.
The bar syntax indicates that the preceding expression produces the following expression.
When a value is bound by a type that has invariants, each invariant is checked as a <em>precondition</em> to satisfy that type.
If a bound value does not satisfy its type's preconditions, then an error will occur.</p>
<p><em>Postconditions</em> are the dependent properties that we know about any given value.
We may not know the exact value of a term, however we may know some of its properties.
When this happens, we can often use the postconditions of a type to complete a proof.</p>
<p>In the above example of Factor23, we know that any value of that type will divide evenly into 2 and 3.
This can be used as part of a proof, or in a program it can be used for constant folding.</p>
<pre><code class="language-lsts">let x:Factor23;
if x%2 == 0 then {
   //yes, always this branch
} else {
   //no, never this branch
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constant-types"><a class="header" href="#constant-types">Constant Types</a></h1>
<p>Constant Types have their own Kind.
Constants are very important in most programs because they validate the invariant properties of types.
All Constants are either Integer or Boolean values.
There are also some builtin functions for manipulation of Constant values.</p>
<p>Some values are given constant types. This creates a relationship between Term values and Constant types.</p>
<pre><code class="language-lsts">1: [1];
4: [4];
</code></pre>
<p>When a Term does a computation, sometimes the Type might also follow along at the type level.</p>
<pre><code class="language-lsts">1 + 3 : [1 + 3]
</code></pre>
<p>Type invariants are evaluated in the context of Constant types.</p>
<pre><code class="language-lsts">let x:Odd;
x % 2 : [1]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-unification"><a class="header" href="#type-unification">Type Unification</a></h1>
<p>Unification is the process of testing whether one type implies another.
Sometimes unification is written as A &lt;: B, which is called subsumption.
For our use we tend towards arrow notation A =&gt; B which is called implication.
The primary difference between the two is the directionality of the operation.
A &lt;: B is equivalent to B =&gt; A, for the extent of our usage at least.</p>
<p>In LSTS we often use the term Property and Type interchangeably.
The primary difference in usage between these two concepts is how they are attached to Terms.
A Term can typically have many properties.
A Term can typically have only one type.
We break this convention when we say that Types <em>are</em> Properties.
In LSTS, Terms have multiple Properties.
Equivalently, Terms have multiple Types.</p>
<p>This would be all well and good if there were no consequences to this breaking from convention.
There are consequences however.
Due to these consequences we sometimes need to say, <em>there can only be one type</em>.</p>
<p>One case where you can only have one type is in a normal kind.
It does not make much sense to say that a term is both a Second and a Metre.
A measurement can only have one Unit.
We extend this principal to apply to all normal kinds.
Normal kinds can only be inhabited by a single Type.</p>
<p>A similar situation appears when we talk about representation of Terms.
It is OK to say that a term is an Odd Integer, but not a String Integer.
Both String and Integer are <em>valued types</em>.
Valued Types have a representation and imply a value.
Terms are only allowed to have one Valued Type.
Valued Types are sometimes called Data Types.
Data Types are singular.</p>
<p>This preface is all we need to explain before even getting started to talk about unification.
Unification is the beating heart of LSTS and it is very important that we get it right.</p>
<h3 id="unification-as-implemented"><a class="header" href="#unification-as-implemented">Unification, as implemented</a></h3>
<p>First let's look at the structure of a Type before we start moving anything around.</p>
<pre><code class="language-lsts">type Type =
     Any
   | Named(String,Type[])
   | And(Type[])
   | Arrow(Type,Type)
   | Tuple(Type[])
   | Product(Type[])
   | Ratio(Type,Type)
   | Constant(Term)
</code></pre>
<p>Bottom is represented as the empty conjunctive.
Tuple is order-sensitive.
Nil is represented as the empty tuple.
Product is order-insenstive.</p>
<p>Unification is represented as the binary arrow operator: A =&gt; B.
However, before we can start unification we must satisfy some preconditions.
The following function gets called before any unification.</p>
<pre><code class="language-lsts">let apply_preconditions( left_type: Type, right_type: Type ) = {
    //rewrite Types with implied types explictly included
    //A + A =&gt; B will be rewritten as A + B
    expand_subtypes( left_type );               
    expand_subtypes( right_type );

    //Constant types will be evaluated and normalized
    //Constants may not become a Value, but they will be normal
    reduce_constant_expressions( left_type );
    reduce_constant_expressions( right_type ); 

    //Types will be converted into CNF
    //Products and Ratios will be reduced and ordered
    normalize( left_type ); 
    normalize( right_type );

    //Assert that all preconditions are satisfied
    //Check that Type is in CNF
    //Check that Normal Kinds and Data Types are singular
    assert_preconditions( left_type );
    assert_preconditions( right_type );
}
</code></pre>
<p>The actual unification function can be very fragile in some cases.
How each case is treated has an outsized effect on the rest of our codebases.</p>
<pre><code class="language-lsts">let $&quot;=&gt;&quot;(left_type: Type, right_type: Type): Type {
   match (left_type, right_type) {

      //the bottom type implies nothing
      (And(lts), _) if lts.length==0 =&gt; { raise TypeError(&quot;Bottom implies nothing&quot;) },

      //any type implies Any type
      (l, Any) =&gt; { l },

      //type variables get substituted for their greatest-common-denominator
      (Named(lv,lps), rt) if lv.is_uppercase =&gt; {
         if lv in substitutions {
            substitutions[lv] = gcd(substitutions[lv], rt)
         } else {
            substitutions[lv] = rt
         };
         substitutions[lv]
      },
      (lt, Named(rv,rps)) if rv.is_uppercase =&gt; {
         if rv in substitutions {
            substitutions[rv] = gcd(lt, substitutions[rv])
         } else {
            substitutions[rv] = lt
         };
         substitutions[rv]
      },

      //And Unification has highest precedence
      (_, And(rts) as rt) if rts.length==0 =&gt; { rt },
      (And(lts) as lt, And(rts)) =&gt; {
         let mts = [];
         for rt in rts {
            match lt =&gt; rt {
               And(tts) =&gt; { mts.append(tts); },
               tt =&gt; { mts.push(tt); },
            }
         }
         mts.sort(); mts.dedup();
         if mts.length==0 { raise TypeError(&quot;nothing implies Bottom&quot;) }
         else if mts.length==1 { mts[0] }
         else { And(mts) }
      },
      (And(lts), rt) =&gt; {
         let mts = [];
         for ltt in lts {
            //it is OK if everything doesn't unify
            //it is not OK if nothing unifies
            if let Ok(nt) = try {ltt =&gt; rt} {
               match nt {
                  And(tts) =&gt; { mts.append(tts); },
                  tt =&gt; { mts.push(tt); },
               }
            }
         }
         mts.sort(); mts.dedup();
         if mts.length==0 { raise TypeError(&quot;nothing implies Bottom&quot;) }
         else if mts.length==1 { mts[0] }
         else { And(mts) }
      },
      (lt, And(rts)) =&gt; {
         let mts = [];
         for rt in rts {
            if let Ok(nt) = try {lt =&gt; rt} {
               match nt {
                  And(tts) =&gt; { mts.append(tts); },
                  tt =&gt; { mts.push(tt); },
               }
            } else {
               raise TypeError(&quot;Implicit Narrowing of And Types is not permitted on the right&quot;)
            }
         }
         mts.sort(); mts.dedup();
         if mts.length==0 { raise TypeError(&quot;nothing implies Bottom&quot;) }
         else if mts.length==1 { mts[0] }
         else { And(mts) }
      }

      //Ratio Types have next precedence
      (Ratio(nl,dl), Ratio(nr,dr)) =&gt; {
         Ratio(nl =&gt; nr, dl =&gt; dr)
      },
      (lt, Ratio(nr,Tuple(dr))) if dr.length==0 =&gt; {
         lt =&gt; nr
      },

      //Everything else is a mixed bag
      (Named(lv,lps), Named(rv,rps)) if lv==rv &amp;&amp; lps.length==rps.length =&gt; {
         Named(lv, [for (lp,rp) in zip(lps,rps) yield (lp =&gt; rp)])
      }
      (Arrow(pl,bl), Arrow(pr,br)) =&gt; {
         Arrow(pl =&gt; pr, bl =&gt; br)
      },
      (Product(la), Product(ra)) if la.length==ra.length =&gt; {
         Product([for (lt,rt) in zip(la,ra) yield (lt =&gt; rt)]
      },
      (Tuple(la), Tuple(ra)) if la.length==ra.length =&gt; {
         Tuple([for (lt,rt) in zip(la,ra) yield (lt =&gt; rt)]
      },
      (Constant(lt), Constant(rt)) =&gt; {
         if lt == rt {
            Constant(lt)
         } else {
            raise TypeError(&quot;Constant Types are not equal&quot;)
         }
      }
   }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kinds"><a class="header" href="#kinds">Kinds</a></h1>
<p>Kinds are <em>types for types</em>.
Kinds are simple, having a name and potentially some parameters.
Types have exactly one Kind.
Terms can have multiple Types, so they can have multiple Kinds.
Types are attached with a single colon.
Kinds are attached with a double colon.
There are 3 builtin Kinds: Term, Constant, and Nil.
New kinds do not need to be defined before they are used.</p>
<pre><code class="language-lsts">5 : Prime :: Term;
2 : Second :: Unit;
1 : [1] :: Constant;
3 : [3] + Integer + Second :: Constant + Term + Unit;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="normal-kinds"><a class="header" href="#normal-kinds">Normal Kinds</a></h1>
<p>We have mentioned that types can be marked as normal.
When any Type is marked as normal, the entire Kind that it belongs to is marked as normal.
The kind Term can never be marked as normal.
Attempting to mark a Term Type as normal will result in an error.</p>
<p>Normal kinds are very useful during typecasting.
For most typecasting, the cast must be direct.</p>
<pre><code class="language-lsts">let a : Real;
let b : Integer = a as Integer;
</code></pre>
<p>For normal kinds, typecasting will search for a viable path that will satisfy the cast.
Normal typecasting has two phases: the Into-Normal phase, and the Out-Of-Normal phase.</p>
<p>During the Into-Normal phase, the compiler will try to normalize the type.
Multiple casts may be necessary to accomplish this transformation.</p>
<pre><code class="language-lsts">let mph: Mile / Hour;
let mps: Metre / Second = mph as Meter / Second;
</code></pre>
<p>In the above example, the compiler must typecast both Miles to Metres and Hours to Seconds.
Note also that the Hours to Seconds cast is on the denominator.
When a Unit cast is on the denominator, the constant conversion factor must be inverted.
A well implemented prelude will take this into account.</p>
<p>During the Out-Of-Normal phase, the compiler will try to take the normalized type and convert it into the annotated type.
This process works mostly identical to the Into-Normal phase, only with a different target.
When Into-Normal and Out-of-Normal phases are connected, multi-step casting can be inferred for fairly complex targets.</p>
<pre><code class="language-lsts">let mph: Mile / Hour;
let kmpm: Kilo&lt;Metre&gt; / Minute = mph as Kilo&lt;Metre&gt; / Minute;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operations-on-kinds"><a class="header" href="#operations-on-kinds">Operations on Kinds</a></h1>
<p>Sometimes we need to manipulate Kinds or check their properties.
For this we have several operations that work on Kinds.
The definition for Kinds is very simple.
Kinds can be Nil, Named, or multiple Named.</p>
<pre><code class="language-lsts">type Kind =
     Nil
   | Named(String,Kind[])
   | And(Kind[])
</code></pre>
<p>The first operation on Kinds is the implication operator.
This is similar to the Type implication operator, just much simpler.
If a first Kind contains all of the second Kind, then the first implies the second.</p>
<pre><code class="language-lsts">let $&quot;=&gt;&quot;(left_kind: Kind, right_kind: Kind): Boolean = {
   match (left_kind, right_kind) {
      (_, Nil) =&gt; { True },
      (Nil, _) =&gt; { False },
      (Named(_), Named(_)) =&gt; { left_kind == right_kind },
      (And(ks), Named(_)) =&gt; { right_kind in ks },
      (Named(_), And(ks)) =&gt; { False },
      (And(lks), And(rks)) =&gt; { rks in lks },
   }
}
</code></pre>
<p>The second significant operation on Kinds is conjoining two Kinds.</p>
<pre><code class="language-lsts">let $&quot;+&quot;(left_kind: Kind, right_kind: Kind): Kind = {
   match (left_kind, right_kind) {
      (_, Nil) =&gt; { left_kind },
      (Nil, _) =&gt; { right_kind },
      (Named(_), Named(_)) =&gt; { And([left_kind, right_kind]) },
      (And(ks), Named(_)) =&gt; { And(ks.append(right_kind)) },
      (Named(_), And(ks)) =&gt; { And(ks.append(left_kind)) },
      (And(lks), And(rks)) =&gt; { And(lks + rks) },
   }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-programs"><a class="header" href="#example-programs">Example Programs</a></h1>
<p>LSTS is also a programming language so you can use it to calculate and discover answers to questions.
More than just existential proofs, programs can be used to compute.
That is why we call it Computer Science.</p>
<p>LSTS takes inspiration from both Haskell and ML for its syntax and semantics.
This might surprise some to say that LSTS is like both of these languages.
The reason for the surprise is that Haskell is lazily evaluated, whereas ML is eager.
You can't have both... can you?</p>
<p>LSTS leaves as much as possible up to the programmer.
For example, LSTS is derived from Typed Lambda Calculus, but it derives no types.
Similarly, LSTS has no builtin evaluation strategy.
When choosing a backend that implements an evaluation strategy, then the programmer must choose between lazy or eager, but not until then.
LSTS just type-checks things, and <em>nothing</em> else.</p>
<p>Here are some backends that LSTS can target:</p>
<ul>
<li><a href="https://github.com/Kindelia/HVM">HVM</a>
<ul>
<li>lazy</li>
<li>massively parallel</li>
<li>compiled or interpreted</li>
<li>compilation outputs platform binary or WASM</li>
</ul>
</li>
</ul>
<h3 id="code-playground"><a class="header" href="#code-playground">Code Playground</a></h3>
<p><label for="lang">Choose a language to run:</label>
<select name="lang" id="lang"></p>
<option value="hvm">HVM</option>
</select>
<label for="args">Arguments:</label>
<input type="text" id="args" name="args" value="10">
<button type="button" id="run">Run</button>
<div id="run_output"></div>
<pre><code class="language-HVM editable">// Creates a tree with `2^n` elements
(Gen 0) = (Leaf 1)
(Gen n) = (Node (Gen(- n 1)) (Gen(- n 1)))

// Adds all elements of a tree
(Sum (Leaf x))   = x
(Sum (Node a b)) = (+ (Sum a) (Sum b))

// Performs 2^n additions in parallel
(Main n) = (Sum (Gen n))
</code></pre>
<script>
$( document ).ready(function() {
   $( "#run" ).click(function() {
      let lang = $("#lang").val();
      let args = $("#args").val();
      let code = "";
      $(".ace_line").map(function(i,v){ code += $(v).text() + "\n"; });
      let rq = { "source":code };
      const p = args.split(" ");
      for (var pi = 0; pi < p.length; pi++) {
         rq[ "p" + (pi+1) ] = p[pi];
      }
      $.post("https://api.ngrama.com/"+lang, JSON.stringify(rq), function(data, status) {
         let ok = false;
         let res = "";
         if (status != "success") {
            res = data;
         } else if (data.error) {
            res = data.error;
         } else if (data.result) {
            ok = true;
            res = data.result;
         } else {
            res = "Unknown Error";
         };
         $("#run_output").text(res);
         if (ok) {
            $("#run_output").css({"background-color": "#9be9a8"});
         } else {
            $("#run_output").css({"background-color": "#ffcccc"});
         }
      });
   });
});
</script>
<div style="break-before: page; page-break-before: always;"></div><h1 id="finding-right-triangles"><a class="header" href="#finding-right-triangles">Finding Right Triangles</a></h1>
<p>Haskell has great list comprehensions.
Iterators in LSTS are not that bad either.
One great example of list comprehensions comes from a popular <a href="http://learnyouahaskell.com/starting-out#texas-ranges">Haskell Tutorial</a>.
In this example, Haskell is used to find all right triangles with a perimeter of length 24.</p>
<p>Here is the Haskell code.</p>
<pre><code class="language-haskell">[ (a,b,c) | c &lt;- [1..10], b &lt;- [1..c], a &lt;- [1..b], a^2 + b^2 == c^2, a+b+c == 24]
</code></pre>
<p>Here is the LSTS code.</p>
<pre><code class="language-lsts">[ for c in range(1,10) 
  for b in range(1,c)
  for a in range(1,b)
  if a^2 + b^2 == c^2 &amp;&amp; a+b+c == 24
  yield (a,b,c) ]
</code></pre>
<p>LSTS takes more characters to write the same program.
However, I think seeing LSTS for the first time would be easier to read.
This is how list comprehensions compare for these two languages.</p>
<p>The output for both programs should be [(6,8,10)].</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jump-as-a-control-flow-primitive"><a class="header" href="#jump-as-a-control-flow-primitive">Jump as a Control Flow primitive</a></h1>
<p>It may suprise some to find out that LSTS has non-functional control flow operators.
Namely, <em>return</em> and <em>raise</em> both potentially cause stack unwinding to occur.
We can account for this control flow in a functional program by using Monads.
However, it still doesn't <em>feel</em> functional.</p>
<h3 id="return"><a class="header" href="#return">Return</a></h3>
<p>Return yields control flow to the end of the function providing a return value.
Even Haskell has a return operator.
In Haskell, the return function is defined as part of Monad and maybe works a little different than a naive programmer would expect.
In LSTS, the return function actually just jumps to the end of the function.
LSTS is not <em>pure functional</em> in this sense.</p>
<h3 id="raise"><a class="header" href="#raise">Raise</a></h3>
<p>The <em>raise</em> keyword is even more problematic to explain in a functional perspective.
Raising exceptions can potentially throw control flow back several function calls until it is caught.
An exception is either caught by a <em>try</em> block or else it will trace all the way up the call stack to cause a Runtime Error.
Some languages may use Result types to make exceptions more explicit.
In LSTS the type system is powerful enough to infer Results, so we save the programmer some trouble and just let exceptions fly.</p>
<h3 id="functional-programming"><a class="header" href="#functional-programming">Functional Programming</a></h3>
<p>Some of our backends don't like dirty control flow.
This is OK.
Monadic code will be generated, but it still may not <em>feel</em> functional.
This control flow is a lie.
LSTS is still purely functional, though it may not seem so.</p>
<pre><code class="language-lsts">fn what_error(x: Integer) {
   raise TheError(&quot;Where is my type signature...&quot;)
}

fn catch_error() {
   match try { what_error(3) } {
      Ok(()) =&gt; { print(&quot;OK&quot;) }
      Error(TheError(msg)) =&gt; { print(msg) }
   }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="batteries-not-included"><a class="header" href="#batteries-not-included">Batteries Not Included</a></h1>
<p>The title of this example is a pun on the Python motto &quot;batteries included&quot;.
LSTS is a type-checker.
LSTS does <em>nothing</em> else.</p>
<p>LSTS may connect with a bunch of other software products that include batteries.
However, LSTS by itself is very minimal.
LSTS does not even define &quot;if&quot;, although it is given special syntax.</p>
<p>In this example we define &quot;if&quot;.
An if statement has three arguments.
One argument for the Boolean branching condition.
Two arguments for each conditional branch.
The if statement returns the value of one of the branches.
All branches and the return type are parameterized.
The shared parameter will become the greatest-common-denominator of both branches.</p>
<pre><code class="language-lsts">let $&quot;if&quot;(condition: Boolean, branch1: A, branch2: A): A;
</code></pre>
<p>The same lack of features applies to the type system as well.
The Boolean type referenced above must be defined by the user.
Boolean types are somewhat special in that they also have dependent types carried along with them.
To denote this special relation, we mark the type as Constant by adding the <em>constant</em> keyword.</p>
<pre><code class="language-lsts">type constant Boolean = True | False;
</code></pre>
<p>Numbers are user defined as well.</p>
<pre><code class="language-lsts">type Number;
type constant Integer: Number = /^[0-9][_0-9]*([eE][_0-9]+)?$/;
type          Real   : Number = /^[0-9][_.0-9]*([eE][-]?[_0-9]+)?$/;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proofs"><a class="header" href="#proofs">Proofs</a></h1>
<p>LSTS is a theorem prover. LSTS may also be a programming language.</p>
<p>LSTS proofs are built on something called the Curry-Howard Equivalence.
The equivalence states and demonstrates that programs are proofs and that proofs are programs.
There is a virtuous one-to-one correspondence between proofs and programs.
Despite this wonderful finding, most programs do not intend to be proofs.
Likewise, most proofs do not intend to be programs.</p>
<p>LSTS is built for this Equivalence.
Programs that look like just code, may actually be intended as a proof.
Following are some examples of how we can make use of LSTS and the Curry-Howard Equivalence to write better programs and more easily certify proofs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trivial-proofs"><a class="header" href="#trivial-proofs">Trivial Proofs</a></h1>
<p>Some proofs are so simple that just stating the goal is enough for our system to infer the validity of the proof.
Most commonly this happens with value manipulation where constant folding will infer that a statement is true without any further work from the programmer.</p>
<pre><code class="language-lsts">forall x:Integer. x + 0 == x;

forall x:Integer, y:Integer. x + y == y + x;

forall x:Integer, y:Integer, z:Integer. x + y + z == z + y + x;
</code></pre>
<p>Q.E.D.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proof-of-the-irrationality-of-the-square-root-of-two"><a class="header" href="#proof-of-the-irrationality-of-the-square-root-of-two">Proof of the Irrationality of the Square Root of Two</a></h1>
<p>Proposition: The square root of 2 is irrational.
Proof:</p>
<pre><code class="language-lsts">let $&quot;/&quot;(x:X, y:Y): X/Y;
let $&quot;*&quot;(x:X, y:Y): X*Y;
let square(x:X): X*X;

type Pt; let p:Pt;
type Qt; let q:Qt;
let sqrt_of_two: Pt/Qt;

square(sqrt_of_two) * square(q): Pt*Pt; //2 * q*q = p*p
square(p) / square(sqrt_of_two): Qt*Qt; //p*p / 2 = q*q
p / square(sqrt_of_two) : ?/();         //2 is a factor of p
</code></pre>
<p>We define rational division, multiplication, and square of whole numbers.
Whole numbers are proposed at the type level, rather than at the term level.
Any whole number may be represented as a type T.</p>
<p>Let p be a whole number Pt.
Let q be a whole number Qt.
Suppose the square root of 2 can be represented as a rational number, having numerator Pt and denominator Qt.</p>
<p>By definition the square of the square root of 2 should be equal to 2.
Therefore 2 is equal to (Pt * Pt)/(Qt * Qt).
By the following algebraic manipulation we show that 2 must be a factor of p.
(Pt * Pt)/(Qt * Qt) is not a factor of p.
Therefore the square root of 2 cannot be rational.</p>
<p>Q.E.D.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proof-of-the-infinitude-of-prime-numbers"><a class="header" href="#proof-of-the-infinitude-of-prime-numbers">Proof of the Infinitude of Prime Numbers</a></h1>
<p>Proposition: There is an infinite number of Prime numbers. Proof:</p>
<pre><code class="language-lsts">let primes:Prime[];
let p = primes.product() + 1;
forall d:primes. p%d == 1;
</code></pre>
<p>Suppose that there are a finite number of Prime numbers.
A Prime number is any Integer greater than 1, not evenly divisible by other Prime numbers.</p>
<p>Let p be the product of all Prime numbers plus 1.</p>
<p>No Prime is a factor of p.
Therefore p is a Prime number.
p is not in the list of Prime numbers.</p>
<p>Our supposition that there is a finite number of Prime numbers leads to a contradiction.
Therefore the Prime numbers must be infinite.</p>
<p>Q.E.D.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lsts-command-line-interface"><a class="header" href="#lsts-command-line-interface">lsts Command Line Interface</a></h1>
<p>LSTS is distributed as a Command Line tool.
The program processes files ending with the <em>.tlc</em> file extension.
<em>.tlc</em> stands for Typed Lambda Calculus.
To find a list of available commands, type <em>lsts help</em>.</p>
<pre><code class="language-lsts">lsts help
     parse [filenames] -- parse files but nothing more
     check [filenames] -- parse and typecheck files
     build [filenames] -- compile provided files as a program
     run   [filenames] -- execute provided files as a program
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lsts-parse-documentation"><a class="header" href="#lsts-parse-documentation">lsts parse Documentation</a></h1>
<pre><code class="language-lsts">lsts help
     parse [filenames] -- parse files but nothing more
     check [filenames] -- parse and typecheck files
     build [filenames] -- compile provided files as a program
     run   [filenames] -- execute provided files as a program
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lsts-check-documentation"><a class="header" href="#lsts-check-documentation">lsts check Documentation</a></h1>
<pre><code class="language-lsts">lsts help
     parse [filenames] -- parse files but nothing more
     check [filenames] -- parse and typecheck files
     build [filenames] -- compile provided files as a program
     run   [filenames] -- execute provided files as a program
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lsts-build-documentation"><a class="header" href="#lsts-build-documentation">lsts build Documentation</a></h1>
<pre><code class="language-lsts">lsts help
     parse [filenames] -- parse files but nothing more
     check [filenames] -- parse and typecheck files
     build [filenames] -- compile provided files as a program
     run   [filenames] -- execute provided files as a program
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lsts-run-documentation"><a class="header" href="#lsts-run-documentation">lsts run Documentation</a></h1>
<pre><code class="language-lsts">lsts help
     parse [filenames] -- parse files but nothing more
     check [filenames] -- parse and typecheck files
     build [filenames] -- compile provided files as a program
     run   [filenames] -- execute provided files as a program
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="soundness-guarantees"><a class="header" href="#soundness-guarantees">Soundness Guarantees</a></h1>
<p>Surprisingly, or maybe not to some, LSTS does not provide the same level of soundness guarantees enjoyed by other systems.
Hopefully this problem is temporary.
Currently there is no constructive proof of the logical soundness of the type system.
Similarly there is currently no proof that the type system is strongly normalizing.</p>
<p>While many of these things may improve with time, there are some unique challenges that LSTS faces.
Most of these problems stem from the fact that the user is allowed to ascribe multiple types to terms.</p>
<h3 id="why-are-multiple-types-a-problem"><a class="header" href="#why-are-multiple-types-a-problem">Why are multiple types a problem?</a></h3>
<p>When you have multiple types, it is possible to create a type signature that can only be satisfied by multiple values.
LSTS does not permit multiple valued terms, and the suggestion is fairly absurd.
What should happen in this case is that LSTS should issue a Type Error and terminate.
Currently this does not always happen.</p>
<p>For example, a term can not be both an Integer and a String. The following code can't be satisfied.</p>
<pre><code class="language-lsts">let x: Integer + String;
</code></pre>
<p>The previous example may seem trivial, but this problem is not always so obvious.
Take for example the exclusive definitions of Even and Odd.</p>
<pre><code class="language-lsts">let x: Even + Odd;
</code></pre>
<p>No single number is both Even and Odd.
However, to prove this we need to do some algebra with the definition of Even and Odd.
The contradiction here, or in an even more contrived contradiction, is not trivial.</p>
<h3 id="so-what-do-we-do"><a class="header" href="#so-what-do-we-do">So what do we do?</a></h3>
<p>LSTS issues Type Errors when it sees a problem.
It may need some help in seeing the contradiction.
This is what extended proofs are for.
There is no end-all for squashing contradictions here.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kinded-proofs"><a class="header" href="#kinded-proofs">Kinded Proofs</a></h1>
<p>Kinds allow the program to setup a &quot;cleanroom&quot; environment for the type system.
The canonical example of polykinding is for the Unit kind.</p>
<p>The International System of Units defines a unit as a Number combined with a Unit.
In LSTS this can be modelled as the number being a Term and the unit being a Unit.
The SI system additionally defines several units as &quot;base units&quot;.
All units that are not base units can be written as a compound of base units.
Examples of base units are <em>Seconds</em> or <em>Metres</em>.
Examples of non-base units are <em>Joules</em> or <em>Teslas</em>.</p>
<p>In LSTS it is convenient to mark base units as <em>normal</em>.
A normal Type can be preferred during type conversion.
For example, if a unit of Speed is multiplied by a unit of Time, it will result in a unit of Distance.
When we look closer at these units we see that Speed is a unit of Distance over Time.
It is only within this normal form that we can discover that Speed * Time = Distance.</p>
<h3 id="kinded-projection"><a class="header" href="#kinded-projection">Kinded Projection</a></h3>
<p>If you want to work within a Kind and only within that Kind then you should use Kind Projection.
A compound Type <em>x: Real + Second</em> can be narrowed into a Unit with double colon syntax:
<em>x :: Unit</em>. This will leave the term with only the type Second, stripping the variable of its other associated Types.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="benchmark-statistics"><a class="header" href="#benchmark-statistics">Benchmark Statistics</a></h1>
<div class="table-wrapper"><table><thead><tr><th>benchmark</th><th>time</th></tr></thead><tbody>
<tr><td>big file 10k loc</td><td>22.937 ms</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="contributors"><a class="header" href="#contributors">Contributors</a></h1>
<p>Here is a list of the contributors who have helped improving LSTS.</p>
<ul>
<li>Andrew Johnson <a href="https://github.com/andrew-johnson-4">andrew-johnson-4</a></li>
</ul>
<p>If you feel you're missing from this list, feel free to <a href="https://github.com/andrew-johnson-4/lsts-tutorial">add yourself in a PR</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>



        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
